{"pages":[{"title":"关于","text":"关于此博客 时不时会出现一些对生活的吐槽和技术的实现的地方。 如果有必要，我会把文章翻译成英语和日语。 由于目前还是条咸鱼 ，这里(可能)会处于并将长期处于长草状态。 近况 Q：那么首先能告诉我你的年龄吗？ A：是20岁 Q：20岁···已经工作了吗？ A：是学生( 又想玩游戏，又想撸代码，甚至还想摸鱼。一天为什么只有24小时.. -圣经咏唱 人間ってのは能力に限界があるな 人間を超えるものにならねばな おれは人間をやめるぞ！ジョジョ―――ッ！！ 我不做人啦！jojo！！！ 技能：C / Python? / C++ 爱好 写 代码 ( Bug ) 有深度的动漫、游戏作品、 推Galgame 古典乐? / 交响乐 / off vocal, instrumental版的流行乐 / galgame的BGM 欣赏 真正的艺术 联系方式 QQ: 2142585130 GMail: guoxitsai@gmail.com","tags":"pages","url":"//tooisorahe.com/about.html"},{"title":"LU分解求逆矩阵","text":"最近在写一个小玩意，需要进行大量的4*4矩阵运算(乘法、求逆)，且对性能有 比较高的要求，所以特地研究一下。 在矩阵阶数比较小且算法不会过于复杂的前提下，改变矩阵乘法算法带来的效率提升可以小到忽略不计； 要得到明显的效率提升一般都是从底层入手，可以调整代码的执行顺序以针对访问内存进行优化或是使用 指令集，这是后话。乘法算法我所知的有Definition和Strassen。两种方法差距如下 Strassen： \\(O(n&#94;{2.81})\\) <----->Definition： \\(O(n&#94;3)\\) 据查到的实验数据显示，只有当矩阵阶数在300以上时Strassen才会明显优于定义； 因我需要计算的只是4阶的方阵，所以直接用定义计算还方便一些。 虽然乘法方面不会对效率产生多少影响；但对于矩阵求逆来说，算法上的优化是有必要的。 如果使用定义法，先算出伴随矩阵后再除以行列式来求逆，其时间複雜度为O(n&#94;4)(要算出每个元素的代数余子式)； 在大量运算的基础下势必会对运行效率造成影响。 除伴随矩阵法之外，我所知的矩阵求逆方法还有高斯消元法和LU分解法 高斯消元法(Gauss elimination)是考试常用方法，求A的逆矩阵时b为单位阵(Identify Matrix)， 过程是利用初等行变换令原矩阵和单位阵同时变换，当原矩阵转换单位阵时元单位阵即为逆矩阵。 编程实现时一般使用其变种Gauss-Jordan elimination， 求解过程 算法比较简单，按照规则逐行约化就行。 Gauss elimination的结果是上三角矩阵，要得到最终解还需要一个代入数值求解的过程； 而Gauss-Jordan elimination的结果是单位阵，可以直接得到线性方程组的解。 LU分解(LU decomposition)是计算机中常用的求线性方程组的算法，现有的大部分数学库的 求线性方程组算法都基于LU分解设计；既然是用于求线性方程组，那自然也能用于求逆。 它的想法很容易理解。数值计算中有一个经验定律：能不直接算 \\(A&#94;{-1}\\) 就不算。 所以将一个方阵分解成一个上三角阵和一个下三角阵，它们的乘积等于元矩阵就是LU分解 的基本思想。 \\(A = LU\\) 根据基本定理有： \\(A&#94;{-1} = (LU)&#94;{-1} = U&#94;{-1}L&#94;{-1}\\) L、U分别为下、上三角矩阵，对它们分别求逆显然比直接对原矩阵求逆要来得简单； 另一个求逆思路是解线性方程组。 LU分解用于求解线性系统的思路如下(解线性方程组) \\begin{equation*} Ax = b \\end{equation*} \\begin{equation*} A = LU \\end{equation*} \\begin{equation*} LUx = b \\end{equation*} \\begin{equation*} 令 y = Ux,则Ly = b \\end{equation*} \\begin{equation*} Ux = y \\end{equation*} 当b为单位阵时x为逆矩阵。 伪代码( 来源 ) 但这样的算法在计算机上实现时会有运算问题，当Ujj为0时分母为0；为了避免这一点，需要使用LU分解 的变种LUP分解。 其原理和LU分解相似，但逐行消元时要选择该列最大的元素来规避除0(还有保持数值稳定， 令Lij<=1)。实现的方法是引入一个置换矩阵P，在消元时将该列绝对值最大的项置换到当前行，如果列绝对值 最大值为0，则这个矩阵是奇异的，不存在逆。 \\(L_{n-2}P_{n-2}...L_1P_1L_0P_0A = U\\) \\(PA = LU\\) \\(P = \\prod_{i=0}&#94;{n-2}P_i\\) 伪代码( 来源 ) 我个人的LUP求逆实现。Matrix4x4是我封装的4x4矩阵类，可视作2维数组 inline bool LUPdecomposition(Matrix4x4& A, Matrix4x4& L, Matrix4x4& U, int* P) { const int n = 4; int row = 0; for (int i = 0; i < n; ++i) P[i] = i; for (int i = 0; i < n-1; ++i) { Float max = 0.0; for (int j = i; j < n; ++j) { // 最大元素所在行 Float cur = std::abs(A[j][i]); if (cur > max) { max = cur; row = j; } } if (max == 0) { std::cout << \"Singular matrix\" << \"A:\\n\" << A << \"L:\\n\" << L << \"U:\\n\" << U; return false; } if (i != row) { std::swap(P[i], P[row]); } //更新置换矩阵 for (int j = 0; j < n; ++j) // 应用置换矩阵后的A std::swap(A[i][j], A[row][j]); // LU分解，更新A Float u = A[i][i], l = 0.0f; for (int j = i + 1; j < n; ++j) { l = A[j][i] / u; A[j][i] = l; for (int k = i + 1; k < n; ++k) { A[j][k] = A[j][k] - l * A[i][k]; } } } // 从A中作出L、U for (int i = 0; i < n; ++i) { for (int j = 0; j <= i; ++j) { //下三角 if (j == i) L[i][j] = 1.0; else L[i][j] = A[i][j]; } for (int k = i; k < n; ++k) { // 上三角 U[i][k] = A[i][k]; } } return true; } inline void LUPsolve(const Matrix4x4& L, const Matrix4x4& U,const int* P,const Float* b,Float* result) { const int n = 4; Float y[n]; for (int i = 0; i < n; ++i) { // Ly = b 解线性方程组 y[i] = b[P[i]]; for (int j = 0; j < i; ++j) { y[i] = y[i] - L[i][j] * y[j]; } } for (int i = n - 1; i >= 0; i--) { // Ux = y result[i] = y[i]; for (int j = n - 1; j > i; j--) { result[i] = result[i] - U[i][j] * result[j]; } result[i] /= U[i][i]; // x系数可能不为1 } } inline Matrix4x4 Inverse(const Matrix4x4& m) { const int n = 4; Matrix4x4 result; Matrix4x4 IdentityM; Matrix4x4 A, L, U; int P[n]{ 0 }; memcpy(A.mat, m.mat, 16 * sizeof(Float)); LUPdecomposition(A, L, U, P); for (int i = 0; i < n; ++i) { // 每次传入单位矩阵的一列，最后的结果拼接起来再转置为逆矩阵 LUPsolve(L, U, P, IdentityM[i], result[i]); } return (Transpose(result)); } 时间複雜度方面，LU(P)分解和高斯消元都约为 \\(O(n&#94;3)\\) ，看起来没有必要去使用较复杂的LU(P)分解；网上有很多总结都说 LU(P)分解优于高斯消元，但这种说法是片面的，它们的效率高低取决于不同的条件。 对两种方法的时间複雜度细化分析。LU分解：分解成LU两个矩阵约为 \\(O(n&#94;3)\\) ，解Ly = b和Ux = y都约为 \\(O(n&#94;2)\\) ，所以总 时间複雜度约为 \\(O(n&#94;3)+O(n&#94;2)\\) 。高斯消元： \\(O(n&#94;3)\\) 。 以上分析都是针对求解单个线性方程组。但可以发现的是，LU分解第一步的结果L、U矩阵可以存储下来，即 \\(O(n&#94;3)\\) 的操作可以 只做一次；设要求的线性方程组数量为m，则LU分解的複雜度为 \\(O(n&#94;3)+mO(n&#94;2)\\) ，而高斯消元的複雜度为 \\(mO(n&#94;3)\\) ； 所以对于求解多个线性方程组(多个b)的情况，使用LU分解更优于高斯消元，且求解的线性方程组数量越多则越明显；反之亦然，如果线性方程 的数量仅有一个，那么高斯消元效率比较高。对于求逆矩阵，只需要解一个b；按上面所说，用高斯消元会比较快。下面是测试代码 int main(int argc, char* argv[]) { vmath::Matrix4x4 origin; for (int i = 0; i < 4; i++) for (int j = 0; j < 4; j++) origin[i][j] = (int)(drand48() * 10.0); // [0,10) std::cout << \"origin:\\n\" << origin; std::chrono::steady_clock::time_point LUPstart = std::chrono::steady_clock::now(); vmath::Matrix4x4 LUPinv = vmath::Inverse(origin); std::chrono::steady_clock::time_point LUPend = std::chrono::steady_clock::now(); std::chrono::duration<Float> LUP_UseTime = std::chrono::duration_cast<std::chrono::duration<Float>>(LUPend - LUPstart); std::chrono::steady_clock::time_point GJstart = std::chrono::steady_clock::now(); vmath::Matrix4x4 Gaussinv = vmath::GaussJordan(origin); std::chrono::steady_clock::time_point GJend = std::chrono::steady_clock::now(); std::chrono::duration<Float> GJ_UseTime = std::chrono::duration_cast<std::chrono::duration<Float>>(GJend - GJstart); std::cout << \"Gauss Jordan Inverse:\\n\" << Gaussinv; std::cout << \"LUP Inverse:\\n\" << LUPinv; std::cout << \"Multiply:\\n\" << Gaussinv * origin; std::cout << \"LUP Use time: \" << LUP_UseTime.count() << \"s\\n\"; std::cout << \"GJ Use time: \" << GJ_UseTime.count() << \"s\\n\"; } 上面代码的测试结果(O2)： 可以看到结果与元矩阵相乘后的确是一个单位阵。LUP和GJ分别是0.0009ms、0.0007ms，虽然差距很小，但的确是GJ更快一些。 放着一堆带优化的开源数学库不用自己去造轮子，我也是有够无聊( \\begin{equation*} \\begin{matrix} 1 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{matrix} \\end{equation*} if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); var location_protocol = (false) ? 'https' : document.location.protocol; if (location_protocol !== 'http' && location_protocol !== 'https') location_protocol = 'https:'; mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = location_protocol + '//cdnjscn.b0.upaiyun.com/libs/mathjax/2.4.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"tech","url":"//tooisorahe.com/LU-decomposition.html"},{"title":"20岁","text":"一些无关紧要的碎碎念 -以前看过村上春树的《挪威的森林》，里面的一个桥段令我久久不能忘怀 \"对直子的二十岁，我竟有些不可思议。我也好，直子也好，总以为应该 还是在十八岁与十九岁之间徘徊才是。 十八之后是十九，十九之后再十八————如此固然理想。\" 曾经我也有过这样的奇怪感觉，似乎二十岁永远不会有到来的一天。 但我终究二十岁了，之前的疯狂也已离我远去————大概很久之前就 已经离我远去了。大学之后我再也没有过像初、高中那样疯狂的通宵玩游戏， 然后第二天睡到下午三四点的生活。 以前很喜欢五月天这个乐队，也十分认同他们早期的歌，认为那就是青春； 虽然现在依旧喜欢，但再听时似乎已经没有了当年的感觉。(事实上五月天 的最新专辑<自传>也不再以青春为主题，更多的是对乐队十几年的总结) 每每想到过两年毕业后即将面对来自社会的压力，我都有些沮丧；原因是 现在的互联网实在太过发达，平时也难免在网络上接触到一些本行业的负面信息； 想到那些会是自己以后可能要面对的事，多少会有些前路漫漫的失落感。 值生日之际，定下一些未来的小目标 希望以后的自己能少一些浮躁，多观察身边的事物，做一个沉稳的人，并以谦卑的心态待人接物； 虽然已经有了明确的目标，但目前来看仍有相当距离，所以要在此之上还要努力学习才是.. 以及一年至少做一次总结，多回顾过去，思考自己当前的不足。 写于太阳直射的广州","tags":"life","url":"//tooisorahe.com/twenty.html"},{"title":"火之将熄","text":"只是一篇零碎的游戏体验 源初的火焰 前段时间通关了黑魂系列，之后因忙于一些意义不明的学校作业，一直没有时间， 现在忙里偷闲写一写我对这个争议性颇大的ip的感想。 最初了解到黑暗之魂这个ip是在2016年，也就是这个系列的第三部发售的年份； 游戏的监督宫崎英高似乎在这之前就已经凭借ps平台独占游戏 [血源诅咒] 在 游戏界有了一席之地。正因如此，黑暗之魂3在发售后的第一时间就成为了热点 话题；玩家都在讨论，那主播也不能落下；记得当时不管是什么游戏分区，播Dota2 的也好播LOL的也罢，乃至于播CS的都有开荒黑暗之魂3的主播，可见当时的热度之大。 魂系列游戏以难度巨大而著称。当时我也看了几次实况，一开始还挺感兴趣的， 但记得看的那个主播死了七八次连灰古达都过不去(灰烬审判者古达，第一个小boss)， 而这游戏复活点离boss场景还有相当的距离，这意味着死了还要跑图； 再加上魂3剧情背景的需求，其整体的美术风格都是以荒凉、死寂作为基调； 附图一张(灰烬墓地，2560*1440最高画质) 可以想象，一次又一次地被新手村boss一戟剁死，然后在如此场景循环往复的跑图是 多么无聊而又痛苦的事。然后我就被云劝退了(丢人 第二次接触魂3是在好友家中。大一暑假时去好友家里作客，此君算是个 资深宅男 ( ? ) , 热衷于推Galgame， 当然我也喜欢 ；交流了一波推Galgame的心得后，话题不知为何 转到了游戏的剧情，他正好通关魂3不久，便开始宣扬受苦的好处，诸如剧情好、画面好云云。 不过真正让我下决心玩这个游戏的原因并不是这个，而是我无意中看到了魂3的开场cg 巨人尤姆的那段真的太震撼了，可以说我是为了这个boss才去受苦的；然而这个boss 的地图是整个游戏中最小的，相关背景故事也少的可怜，boss战大概是最简单的了吧， 毕竟只有风暴才能击倒大树（。网上有说法是因为经费不足的 原因被阉割掉了，这是令我相当失望的一个点，这么震撼的cg结果整出来就这？ cg里对尤姆的描述原文： ‘the reclusive lord of the Profaned Capital, Yhorm the Giant.' 直译中文应该是\"巨人尤姆，被亵渎都城的隐世王者\"； 而官方的翻译是\"罪业之都的孤独王者，巨人尤姆\"，虽然与原意不同但更贴近npc的背景。 本着遵照剧情的原则，我并没有像大部分玩家一样先玩魂3，而是先去把一代过了一遍； 幸运的是一代18年出了重制版，否则我就要忍受09年的跨时代画质了。二代因为风评过烂， 剧情也和1、3代基本没有联系，所以选择跳过。 从难度上来说，个人认为一代的游戏体验说不上受苦。有可能是老的游戏机制的原因，这一作 的弹反处决异常简单，并没有到令人抓狂的程度。甚至打最终boss时我也只死了7次（，毕竟你 葛温王已经烧了几千年了；至于三代的难度..打完之后我只想问候宫崎英高的老祖宗。本来刚 通魂1兴致勃勃，打开魂3立刻被杂毛小兵教做人，甚至可以说3代的小怪才是boss，至少我灰 古达死两次就过了，然而在其后的洛斯里克高墙死了差不多三十次；结果就是我气急败坏直接开修改器跑图了(，除了 boss战都开无敌，丢人也要有讲究。事实证明修改器就是手残剧情党的救星，可以满地图乱跑 而不用担心哪里冒出个小怪两刀把你砍死的感觉不要太爽。 从我这个按顺序玩的人的角度来看，魂3其实算是个情怀作品。很多一代的场景都在三代中得以 重现。最好的例子就是亚诺尔隆德，在一代尚是神族的王城，到了三代已然荒凉暗淡。 一代王城笼罩在落日的余晖中，看起来金碧辉煌，但这也暗示了传火(神权统治)的结局。 三代王城已变为冷冽谷的附庸，虽然这中间已经度过了以万年为基本单位的岁月，但还是让人 唏嘘不已 这也算是这个系列的游戏的特色，它本身的剧情极度残缺，大部分的背景都散落在游戏内的 物品介绍和游戏环境中，甚至官方都没有给出明确的设定，只能由玩家发掘拼凑，但即使这样， 游戏的剧情也有相当一部分是留白的，无从考证。就拿游戏的剧情来说，一代描述的是由于 原初火焰的诞生，世界由最初的死寂变得生机勃勃；神族凭借初火的力量推翻了不朽古龙的统治， 开启了自己的纪元，但没有火种的火焰终会熄灭，待到初火熄灭，世界恐怕又会变回 原来的样子吧！到那时，神族的时代就结束了。为了延续神权，最强大的神太阳王葛温以身 作柴薪，延缓了初火的熄灭，成为了最初的薪王。乍看是一段值得传颂的历史，实则不然。 初火的火种是强大的灵魂，而神族作为统治者总不能老烧自己人；于是葛温藉著 自己传火的事实，向当时的人类鼓吹传火是光荣的，传火才是人类生存的目的。一代开始时 葛温也快烧完了，主角作为人类的故事从这里开始。 上面这段基本是游戏开头cg的内容。至于详细发生了什么？种族之间的故事？对不起，没了。从整体来看我不喜欢 这种留白太多的风格，虽然它的确有独特的吸引力，至今仍有骨灰级玩家在探究整个黑魂世界的 来龙去脉；但对于普通剧情党来说有点太累了，而且几乎所有的线索都只是来自像这样的物品介绍： 略带些奇妙讽刺的魂式言语在解读时就足够喝上一壶，再说这游戏可是有着上千计的物品.. 火之将熄 关于游戏结局的选择，一代有两个结局：传火和灭火；三代对应一代的传火剧情，有四个结局， 也都是关于灭火还是传火的。然而我一开始就没想过要传火( 玩一代时想着靠烧人来维持运作的世界也太扭曲了，果断灭火；到三代更不用说，传火的谎言 延续了几万年，足够强大到能拉去烧的灵魂也越来越少，甚至已经到了要把烧过的薪王从棺材里 拉出来再烧一次的境地；(跟一代相比我觉得三代只有尤姆可以称得上是薪王了，要知道三代薪王 之一的法兰不死队在一代只是一群小怪..)这样的世界已经没有再延续下去的理由，继续苟延残喘下去也没有意义， 干脆直接把火灭了大家都开心。我可能也是个加速主义者罢(悲) 结合上面提到的剧情缩水、背景零散破碎、游戏难度极高的问题来说， 这种看似留白处理的风格只会让人觉得制作方体量太小，支撑不起这样宏大的剧情； 而过高的难度也让我认为是在强行拖长游戏流程，藉此掩盖实际内容的不足。 所以这个游戏注定就只能是个小众的普通游戏，远远未到神作的高度。 这火我不传，传不了..","tags":"life","url":"//tooisorahe.com/the-fire-fades.html"},{"title":"肖战，永远滴神！","text":"python课大作业的题目是爬任意一个网站，获取数据进行统计。我平时很少看电影， 就算看也不会特意去研究一部电影的评分和影评，电影的好与坏是非常主观的，只有 自己看过后才能得出结论，听风就是雨的行为实在是naive。 我了解到的大多数人都是选择爬取诸如豆瓣、猫眼之类的影评或者书评网站，考虑到 上面提出的问题，这种类型的数据对我而言没有意义，就没有选择这类网站。正苦恼 于选择什么网站时，QQ上收到一张图片，内容大概是某群友跟肖战狂热粉丝的对线内 容。肖战这个名字，就算是不关注娱乐圈的我也是如雷贯耳，此人如今的名气甚至一 度超越身为2019年度之星的坤坤(当然是不好的方面)；想当年，坤坤靠一曲鸡你太美变态出道， 成为全网津津乐道的对象。而当今肖战则更胜一筹，个人实力什么的无所谓，只要粉 丝够多够无脑，我就是饭圈当之无愧的扛把子。 本人亦有幸被肖战的粉丝 临幸 ( 攻击 ) 过，其言语之粗鄙，其态度之恶劣，实在 是所有键盘侠的楷模。藉此次机会，我决定爬一爬肖战的微博，研究一下他 粉丝的构成。 详细(实现具有时效性，一段时间后可能失效) 按照软件工程的说法，首先要对目标进行可行性分析(避免技术力不足造成的尴尬)。我 了解到微博有三个域名：weibo.cn, m.weibo.cn, weibo.com。其中weibo.cn是旧时代的遗物，页面简单， 但信息少；在三个域名中是最好爬的。m.weibo.cn是手机端的页面，信息足够。 weibo.com则是微博的网页版，信息最多，但也最难爬(包含各种验证码、机器识别)， 自带劝退属性。考虑到这次做的只是一个玩具，那么答案已经呼之欲出了————m.weibo.cn， 就决定是你了！ 然后是对网页的json数据结构的解析。我的目标是获得肖战每一篇微博下的评论人的 信息，所以主要研究的是页面的跳转问题(微博->评论页->评论人个人信息页)。 程序的入口是肖战的 微博首页 这个主页有五个分类：主页，微博，视频，超话，相册；每个类有各自的containerid。 由此可知有containerid就能跳转到相应的分类。手机端的微博页并不是将所有微博一次 全部显示出来，而是隐式的将x条微博划分为一页。易知手机的操作方式是往下划动， 所以这里的翻页方式是当滚动条划动到接近当页最后一条微博时请求下一页的所有微博 信息。而每一页微博会有一个since_id指向下一页，所以翻页的方式就很浅显了。 每条微博有专有的id，一条微博的评论页可以通过id获取；评论的翻页方式与微博相同， 不过参数是max_id。 数据可视化使用了pyecharts库，很简单，很好用， 官方文档 的介绍非常详尽 大抵的思路就是这样，下面看下结果。 虽然只有8000个样本，但也足以初见端倪 性别是没有悬念的，至于那10%的男性身份也很好推定。 粉丝的地理分布，北上广深没得跑，意外的是川渝也很密集。 从肖战粉丝的言论看来，这样的世代分布很合理，毕竟是后浪嘛。 不过最令我惊讶的是居然还有5%的10后...真-后浪。 2009年8月14日，新浪微博开始内测。 得益于现在强大的控评和公关，并没有什么参考价值 写这东西大概用时三天，上课边摸边写的，程序本身没有任何难度，逻辑也非常简单； 如果硬要说有坑的话，大概是手机端的微博经常会出现莫名其妙的丢包导致返回不正确 的json数据，在必要的地方加异常处理就可以完美解决。还有就是请求频率不能过快, 否则会被小棺家封号...解决方案是上某宝买点小号建个账号池，如果被封换个Cookie就 完事了。 虽然只是个小玩具，但基本达到了目的。至于结论，不用多说也心知肚明，笑一笑就好。 这都整的什么烂活","tags":"tech","url":"//tooisorahe.com/xz666.html"},{"title":"丐版池塘夜雨","text":"写在前面 因为对图形学比较感兴趣，前段时间陆续看了fundamentals of computer graphics、raytracing系列，了解了一些 图形学的基础知识，也手撸了一遍光追(丐中丐版)。出来的图的效果 看着还行 ： 1000sample per pixel 100sample per pixel 如前面所写的，我之前所了解的都是图形学中离线渲染的部分。可以看到，虽然光线追踪所呈现的效果相对真实，但 如果不加一些黑魔法优化的话，效率太低。我记得渲染第一张图时好像用了5min(600x600)...。离线渲染坑太 多，不是一时半会儿可以搞定的；图形学中还有另外一个分支实时渲染，就像名字中所描述的，效率大都能做到实时，也是 游戏开发的主力，但相对于基本遵循物理定律的光追，真实度方面肯定有所差距。 之前看到过文刀秋二大大的 一篇文章 ，正好这 学期了解了数据结构，与文中的背景基本相似。虽然大作业的题目并不是文中的\"池塘夜雨\"，但由于学校出的题目过于无聊， 索性就尝试一下，顺便学习一些实时渲染方面的知识。 先放上结果： 完成了：天空盒、基本的水面效果(折射反射)、波纹、pbr光照地形、雨点(指雪花) 环境需求：OpenGL3.3-32bit，相对应的GLFW，glm0.9 下面记录一下实现时卡住的地方 雨 记得我是从雨点开始着手这个程序的；一开始想用Geometry Shader给整成粒子特效，写出来之后发现跟想象的效果的差距 有点大，粒子完全就是个像素点，一点都不像雨；思来想去没有头绪，干脆直接用三角形画个球代替一下，于是就有了现在 这样圆形的雨(其实连飘落方式也给写成雪的形式了，或许叫池塘夜雪更合适- -)。思路比较简单，实时渲染中的物体实际是由无 数个三角形面片组成的，所以只需想象一下把N个三角形近似成一个球就明白了。想要OpenGL画一个模型，需要提供模型的顶点 数据，所以问题就变成给定球心和半径，求球面的任意一点的坐标。这时可以将球像地球仪一样按经线和纬线分割；经过切割 后球面可被近似看为由N个矩形组成，一个矩形又由两个三角形组成；计算实际就是球坐标转笛卡尔坐标。灵魂画图： 需要注意的是OpenGL中渲染三角形时按照顶点的顺序来区分正反面，默认逆时针为正面，顺时针为反面；在下面的反射会 用到。球坐标中的θ∈[0, π]， φ∈[0,2π]，代码如下。 void GetPoint(std::vector<float>& p,float u, float v, float r) { constexpr float pi = glm::pi<float>(); float z = r * std::cos(pi * u); float x = r * std::sin(pi * u) * std::cos(2 * pi * v); float y = r * std::sin(pi * u) * std::sin(2 * pi * v); p.push_back(x); p.push_back(y); p.push_back(z); p.push_back(u); p.push_back(v); } (std::vector<float>& vertex, size_t longitude, size_t latitude, float r) { float longitude_step = 1.0f / longitude; float latitude_step = 1.0f / latitude; size_t offset = 0; for (size_t lo = 0; lo < longitude; lo++) { for (size_t lat = 0; lat < latitude; lat++) { std::vector<float> point1, point2, point3, point4; GetPoint(point1,lo * longitude_step, lat * latitude_step, r); GetPoint(point2,(lo + 1) * longitude_step, lat * latitude_step, r); GetPoint(point3,(lo + 1) * longitude_step, (lat + 1) * latitude_step, r); GetPoint(point4,lo * longitude_step, (lat + 1) * latitude_step, r); } } } 第二个解决的是天空盒 这里 的介绍非常详尽。需要注意的是 从Equirectangular Map转换到Cube Map时每次循环都要glclear清一下深度和颜色缓冲...之前就是因为漏写了这一句调试了一下午.. 说多了都是泪。 解决了雨点和天空盒后，能看到的效果是一个飘雨的广袤世界，就像这样：(天空盒资源取自 sIBL ) 池塘夜雨，总不能少了池塘。 最初用的是视差贴图和法线贴图结合，效果也很不错；但视差贴图完全是视觉上的trick，并不是 真实的高度，而之后的水面的实现是在另一个平面上，与地形基本处于同一高度，两个平面的深度冲突会导致只能显示一个平面。 于是转为用displacement mapping实现；displacement mapping实际上就是根据高度图调整顶点位置，这样生成的地形的高度 是真实的，但缺点是如果面数不够生成的地形就会棱角分明，很难看。解决方法是增加面(三角形)的数量，但这样开销也会增大； 生成顶点的代码如下： (size_t rowLen, size_t colLen) { std::vector<glm::vec3> tv; std::vector<glm::vec2> te; size_t triangleNum = (rowLen - 1) * (colLen - 1) * 2; double d = 2.0 / rowLen; for (double z = -1.0; z < 1.0; z += d) { for (double x = -1.0; x < 1.0; x += d) { tv.push_back(glm::vec3(x, 0.0, z)); te.push_back(glm::vec2((x + 1.0) * 0.5, (z + 1.0) * 0.5)); // [-1.0,1.0]->[0.0,1.0] } } 题图为1023*1023*2个三角形，再加上法线贴图的效果。光照用了pbr+IBL， 这个教程 写的太好了，真正的 简单 易懂。 最后是水面，也是最复杂的了。 使用了平面反射来实现水面的反射效果，相比于Screen Space Reflection(SSR)和对cube map采样在 效率和效果上都有优势。SSR的原理是获取当前视空间的深度、法线等信息，然后在后处理阶段通过深度信息得出场景中物体的位置,再 通过光线步进的方式获取反射颜色。方式是从当前点出发，沿着反射方向步进直到碰到物体为止；反射方向可以由法线得到，物体碰撞 则用深度来判断；缺点也很明显，既然只有当前视空间的深度、法线信息，那视空间之外的物体肯定是没有反射了。因此在室外的场景 很容易出现反射缺失的情况。另一种反射方案是将当前场景渲染6次到一个cube map上，再对cube map采样；只是看描述就知道这玩意 开销有多大了，每帧6次..简单的场景还好说，复杂一点直接gg。 而平面反射的原理是将正常camera变换到对称与平面的位置，再用对称相机渲染场景一次作为reflect texture，然后对这个texture 采样就得到反射效果。要将正常camera转换到对称位置，需要一个反射矩阵，下面是公式推导和代码实现。 Planar Reflection glm::mat4 result = glm::mat4(1.0); float d = -glm::dot(normal, p); result[0][0] = 1.0 - 2 * normal.x * normal.x; result[0][1] = -2 * normal.x * normal.y; result[0][2] = -2 * normal.x * normal.z; result[0][3] = -2 * normal.x * d; result[1][0] = -2 * normal.x * normal.y; result[1][1] = 1.0 - 2 * normal.y * normal.y; result[1][2] = -2 * normal.y * normal.z; result[1][3] = -2 * normal.y * d; result[2][0] = -2 * normal.x * normal.z; result[2][1] = -2 * normal.z * normal.y; result[2][2] = 1 - 2 * normal.z * normal.z; result[2][3] = -2 * normal.z * d; result[3][0] = 0; result[3][1] = 0; result[3][2] = 0; result[3][3] = 1; 将获得的反射矩阵在观察空间中变换即可(先乘view再乘reflect)；但这并不是最终结果。当物体在平面下时，反射贴图本应不显示物体 的反射虚像，但由于camera的frustum是下图的形式，所以依然会显示虚像，视觉上的效果是物体翻了个面。解决方法是将frustum的近 平面与反射平面平齐。如下，参考了 这个 。需要启用CULL FACE 将背面裁去，所以生成模型的时候顶点的顺序很重要。 FrustumClipping glm::vec4 viewSpacePlane = glm::transpose(glm::inverse(reflectView)) * plane; glm::vec4 ViewSpaceFraPlanePoint = glm::transpose(glm::inverse(projection)) * glm::vec4(sign(viewSpacePlane.x), sign(viewSpacePlane.y), 1, 1); glm::vec4 M4 = glm::vec4(projection[3][0], projection[3][1], projection[3][2], projection[3][3]); auto u = 2.0f * (glm::dot(M4,ViewSpaceFraPlanePoint) / glm::dot(ViewSpaceFraPlanePoint, viewSpacePlane)); auto newViewSpaceNearPlane = u * viewSpacePlane; auto M3 = newViewSpaceNearPlane - M4; //glm::vec4 M3 = 2.0f * (glm::dot(M4, ViewSpaceFraPlanePoint) / glm::dot(plane, ViewSpaceFraPlanePoint) * C) - M4; projection[0][2] = M3.x; projection[1][2] = M3.y; projection[2][2] = M3.z; projection[3][2] = M3.w; 数据结构的内容 写了个循环队列来控制雨点和波纹的逻辑；每一次渲染循环将雨点出队，修改位置后在入队；如果已经飘落到湖面上则重置雨点位置，然后 往波纹队列中增加一个波纹(在雨点飘落的位置，通过uniform传入shader)。同时将波纹出队，判断生命周期是否结束后入队。 最后 为什么是丐版？ 因为真的就只是把文刀秋二大佬文章中的features做了出来而已..全部代码大概1000行多点， 完全就是屎山 ;最终效果一般而且 还有一些地方偷懒了。 因为之前完全没用过OpenGL，所以耗时比较长，一边学一边写总共用了一个多月。 不得不提OpenGL的api有点反直觉，用起来总有微妙的感觉。因为接近底层的缘故，坑非常多，刚开始的VAO,VBO,EBO折腾了好一会儿才 搞懂。api也相对原始，如果不适当抽象一下的话代码行数立马蹭蹭往上涨，过两天再看会觉得很痛苦。 最后就是写shader的时候没有任何语法提示，出错了只能看那短短几行的错误输出来定位..还好这次的shader并不复杂。 要说有什么收获的话， 大概知道了单机游戏里的图形选项是怎么回事，以及消耗如何 代码水平提升了！ 还有就是顺利地将这玩意当数据结构大作业交上去了=。=，有个开明的老师真的是非常幸运， 这一个多月的时间的价值最终还是体现出来了(指实质意义) 不然的话还要多花点时间在那几个莫名其妙的学校题目上 。 仓促间写的总结，应该会有很多纰漏，还有一些细节也没来得及写出来。学校的作业还没写完，然而我又想玩游戏了；； steam上买了很久的游戏一次都没玩过... 我都花钱买了凭什么还要花时间去玩 总之有时间再改吧(","tags":"tech","url":"//tooisorahe.com/raining-pool-poor-ver.html"},{"title":"一只鹦鹉","text":"半年前家里飞来一只鹦鹉。记得是落在我房间的窗台上歇脚时，被我爸一个菜篮子扣住。 家里有个很久不用的鸟笼，正好养只宠物。也许是从附近的养殖场里偷跑出来的，习惯于被囚禁的生活， 本来在菜篮里上蹿下跳的鹦鹉一看见笼子就径直钻了进去，顿时安定不少。 动物们的故乡是自然，但如今却对铁笼如此趋之若鹜，还是说铁笼才是动物们的故乡？ (一周目黑魂，有点中毒 由于这只鹦鹉的头是黄色的，故命名小黄。上网查了下，品种是黄化玄凤，长这样： 刚逮住的时候凶得很，一旦有摸它的意图就免不了被咬上一口，竹子都能咬断的咬合力， 一口出血是再正常不过了；所以也不敢把它放出来，就这样把它晾了一个月； 某天晚上回家时发现笼子竟然是开着的，想着它肯定越狱了，没想到开灯之后发现它躲在 凳子底下安然自若的睡大觉，发现我回来之后也只是抬了抬头；从这之后笼子就没关过。 维持放养状态几天后开始给我摸头，然后发展到每天都来我房间主动求摸头的状态； 不愧是我的宠物，深知摸到就是爽到的硬道理(赞赏) 玄凤鹦鹉鸡说 这是我对比观察家里养的十多只鸡得出的结论。 鸡是鸟，鹦鹉也属于鸟类。 鸡很少飞，鹦鹉是攀禽，爬能去的场景绝对不会飞，也很少飞 鸡喜欢吃小米，鹦鹉也喜欢吃小米 鸡喜欢在地上跑来跑去，鹦鹉也喜欢在地上跑来跑去 Q.E.D, 玄凤鹦鹉鸡说成立( 为了这货特地去抄了个插件，原版可以引用Youtube的视频，我修改之后可以用于B站，媒介是 rst的行内角色，使用方法是 .. buriburi:: 后接AV/BV号 :page: 可选分p页 陈睿震怒 第一次投稿，我也总算是为建设批站出了自己的一份力了！","tags":"life","url":"//tooisorahe.com/a-parrot.html"},{"title":"为了忘却的记忆","text":"TI9的完美落幕 几个小时前，在中国上海的梅赛德斯奔驰场馆内，OG在BO5的总决赛中以3：1的比分击败Liquid，夺得 TI9的冠军，也借此成为TI九年历史中的第一个双冠队伍，恭喜OG。 写在前面 看完最后的比赛，刷Max+时无意间看到了这篇文章： 如果你对Dota仍有爱意，请将TI9留在风中. 虽然与文章作者算是差了一个时代，但仍有不少相似的地方。再想到自己已经很久没有主动地打开这个游戏，激动之余也有些许感伤， 就趁这个机会写一些文字记录下我的Dota旅程，为这个贯穿我整个青春的游戏留下美好的回忆。 起点 最初接触到这个游戏，是在2012年小学升初中的暑假。而写下这段话的时间已是2019年，我也从一个准中学生转变成了大学生。7年， 这是这个游戏陪伴我的时间，现在回想起来真是一段不可思议的时光。 小学升初中的暑假，由于小学生所知的娱乐方式比较少，大概是比较无聊的。记得那也是一个无聊的下午，大我三岁堂哥来家里玩， 一进门就迫不及待地掏出u盘插到电脑上：\"来看好康的！\" 然后打开了一个叫魔兽争霸3：冰封王座的游戏，开始玩里面的官方地图。 被疯狂人机虐了几盘之后————多操对那时的我们来说可能稍微有点困难 现在还是打不过 ————我哥显得有些无趣之余，打开了 一幅新地图：DOTA6.73AI，我的Dota之路从此开始。 当看到上面这张载入图片时，我已被深深地吸引。第一盘是我哥玩的，隐约记得是名为鱼人夜行者的英雄，最后结果已经模糊不清， 只记得我迫不及待要玩上一盘的模样。Dota1时代是在12个酒馆中挑选英雄，每个酒馆的英雄的主属性都不同，名字也很有\"感觉\"，譬如 暮色酒馆，曙光酒馆之类的。初次接触，那些名字令我眼花缭乱，就选了\"先知\"————看起来比较厉害。被电脑杀了几次后这盘游戏毫无悬念 地落败，记得我是在近卫军团，眼看着自己的世界之树被拆掉是真的很不甘心，但那时的我应该真的爱上了这个游戏。 朋友们 一个游戏的生命力在于玩它的人数。Dota也是一个多人游戏，如果只能与电脑博弈，我对它的热爱也不会到如此程度。 暑假结束后，我正式开始了我的初中生活。在一次玩闹中，不记得是谁无意间提起了这个游戏，在一瞬间发现一群志同道合的朋友， 真的很开心。蒜蓉、伟伟、大师、大葱、浩楚、大亦，直到现在都是我最好的朋友。 现在回想初中的生活是真的非常\"精彩\"。记得当时教师机是固定在教室的，那么它所带来的结果就很显然了———放学后其他班的教室很快就空了， 只有我们班还有几个人围着讲台不知道在捣鼓什么。电脑只有一台，还要提防没走的班主任和级长，分工也已明确。 如果这算是坏事的话， 不知道自习课时打开投影全程大屏幕直播和在图书馆上机区五人连坐美名其曰\"绿色wb\"要怎么定义。 无论好坏与否，这在那个电脑 被管制使用的年纪，是非常难得的娱乐时间。 翻了翻旧手机找出上面两张图片，第一张是开黑截图，第二张是周末通宵。 时代的变迁 上高中之后，考上不同高中的我们仍保持着频繁的联系。此外，Dota2的Ti已经举办了五届，整体质量也在不断提高，Dota1玩家源源不断地 加入到Dota2阵营，我们当然也在其中。毕竟Dota1整体基于War3的引擎，画质已经跟不上时代。而Dota2沿袭了原本玩法的同时不仅画质有 很大的提高，还提供了比较完善的管理，随意退出的情况的到了遏制。在这之外还加入了饰品系统 当初听说Dota2不花钱，现在全家都怀疑我吸毒.jpg 。 有一段时间我也对饰品抱有相当的兴趣，不过这大概是现在我对Dota2失去情热的原因之一吧。起初，饰品的确带来了很大的新鲜感，增加 技能特效的同时还能令英雄模型更好看，饰品介绍上也会完善这个英雄的故事，这是很好的描述游戏背景的方式。但随着Valve不断推出新的 改变特效的饰品，上面的介绍也变得极其简短且重复。譬如说船长2017年的Ti本子奖励，把大招的幽灵船改成了鲨鱼，特效是做足了，但却 使这个游戏的独有魅力渐渐消散。Dota是英文DEFENCE OF THE ANCIENTS的缩写，翻译过来为\"古代遗迹保卫战\"，这样大规模的特效改变， 使得游戏的整体风格也随之改变。我想要的\"感觉\"，具体来说应该是\"史诗一般的战斗\"，而游戏中的人物要有合格的故事之余，还要有与之相称 的背景才能称作史诗。文字说明可能不够准确， 很残念语文作文从来没上过50 由于电脑下面是几张Dota1仍在更新时的载入图片。 DotA6.49-6.54 DotA6.55-6.62 DotA6.63-6.68 DotA6.70-6.72 Dota6.75-6.81 每一张都能带给我身临其境的感觉，相当震撼。 虽然Dota2的画质有很大的提升，但少了点\"感觉\" 所以就我个人而言，Dota2在某种程度上的确失去了一些东西。 第二个原因则是游戏性上的问题。从Dota1到Dota2，这之间经历了无数个版本的迭代；但无论是地图大改，还是英雄重做，都不会改动的是 游戏的随机性；这也是卡牌游戏风靡的原因。一次抽卡，就可以改变一局游戏的结局， ドロー‼ 无限的可能性总是令人心驰神往。 在Dota中也一样，大部分英雄都有着被动技能，也就是概率触发。这类技能一般与暴击、眩晕效果挂钩，这也是它能扭转战局的原因。对我 来说，印象最深的被动技能无疑是混沌骑士(Chaos Knight, CK)的被动\"混沌一击\"。在我刚入坑的那个版本，这个被动升到满级后有11%的 概率打出4倍暴击，而且还是个小技能;而我在一篇总结帖中了解到，在远古版本时这个被动甚至还有额外的效果：%1的概率打出11倍暴击。 血条消失很好地诠释了这个技能的效果。试想，在一次团战中突然打出了一次这样的效果，该是多么的令人兴奋！当然这是不平衡的，要改。 这就是游戏的竞技性与娱乐性的冲突(我认为)，竞技性要求大部分东西是可控的，你这样做了，那就会得到对应的结果，对于现在讲究细节 的职业比赛来说，没有一个战队想要一次戏剧性的意外，毕竟那是吃饭的家伙。而娱乐性就如同上面所说的，讲究随机(也有不少人认为竞技 就是娱乐，但这是我个人对游戏的认识)。比赛能带动游戏热度，v社作为运营商也不是傻子，更新围绕比赛是理所当然的。带来的结果就是 前几个版本的更新中几个英雄的被动不再是概率触发，而是cd后必定触发，CK也在其列。改动面向比赛，这是趋势，但对我而言这多少会让 我觉得这个游戏变得死板了，没那么好玩了。 最后就是背景音乐的问题。虽然按照常理来说没有背景音乐的游戏更贴近现实，但事实则正好相反， 个人认为背景音乐是一种隐式的言语，是用于表达游戏的环境、背景甚至人物的最佳方式。最好的 例子就是日本的galgame，它实际上是仅由cg、文本、音乐组成的游戏，很多时候文本并不足以表现 人物的特征，cg就更不用说了，主要用途是消除纯文本的枯燥。这时配乐的重要性就体现出来了， 个人觉得我推过的galgame中的配乐都非常应景，能很好地表现出人物的性格或事件的主题，不管 是欢快还是悲伤，它们都能让人感同身受，也就是\"代入感\"，所以对于\"音乐是人类最美的语言\"这句话 我是相当赞同。扯远了，回到主题。由于Dota1是魔兽争霸3的一张子地图，所以它的配乐也沿用了 war3的配乐。当年并没有这方面的感觉，玩了几年Dota2回首才发现，这也是这个游戏十分重要的 一环；把War3的OST听了一遍，当初Dota1的背景音应该是 Dark Covenant 和 Return of the Ancients 译名是黑暗契约和远古的回归，分别对应人族和暗夜精灵的背景故事。许久没玩Dota1，再听这两首 bgm时只能用心潮澎湃来形容，那种仿佛置身史诗战场的感觉如今Dota2的各种电音配乐是绝对给不了的。 上面三条也是我现在选择游戏的标准。重要的是剧情、自由度、配乐，画质则不然。 最后 如果从最初的起点算起，Dota已经走过了15个年头(遗憾的是我没能经历那段时光，下面是远古大神整理的资料)。 Dota史前掠影 by云天逝水 5.72-6.27更新日志 by HeavenFord 以一款游戏来说，它的生命已经足够久远。近几年网路上也有不少声音认为它应该寿终正寝了，只看比赛不玩的\"云玩家\"数量也不断增长。 对于我来说，或许目送着它远去就是最好的告别方式了吧。但无论如何，即使我变成了 已经是 所谓的\"云玩家\"，Dota也是我最爱的 游戏，偶尔跟朋友玩上几把，足够了。 经历过Dota1时代的玩家想必不会对蛋疼集锦陌生，当时的直播行业并没有现在这么发达，主流的还是自制视频。蛋疼集锦是其中的佼佼者，可惜也 在两年前断更。而片头的音乐是堀江由衣演唱的<桜>，对当时的我来说，听见这一段音乐，就代表了欢乐时光的开始。 日々を振り返られる 私になりたい 想回到过去 变回最初的自己 桜、散る事 見ないように生きようとした 过着就像看不见樱花飘零 一样的生活 花開く夢さえ 知らないままで... 连花满开的梦 也不曾知晓 祝愿Dota越来越好！————来自一个曾经获得两届TI冠军的男人(","tags":"life","url":"//tooisorahe.com/for-the-memory-that-has-been-forgotten.html"},{"title":"一个简单的BMP编码函数 TOYBMP()","text":"写在前面 计算机图形学(CG)，是一种使用数学算法将二维或三维图形转化为计算机 显示器的栅格形式的科学。其主要的研究内容就是研究如何在计算机中表 示图形，以及利用计算机进行图形的计算、处理和显示。 我对这个领域也有相当的兴趣。为了更好地学习图形学，我尝试写了 TOYBMP() 。 以MIT协议发布。这个函数由C语言实现，可以将数据写入24-bit RGB 或 32-bit RGBA 无压缩的BMP。代码长度为25行。 代码实现如下( toybmp.h )： 用法 #include <stdio.h> #include \"toybmp.h\" unsigned char rgb [ 256 * 256 * 3 ]; int main ( void ) { unsigned char * p = rgb ; for ( int y = 0 ; y < 256 ; ++ y ) { for ( int x = 0 ; x < 256 ; ++ x ) { * p ++ = ( unsigned char ) x ; * p ++ = ( unsigned char ) y ; * p ++ = ( unsigned char ) 128 ; } } toybmp ( fopen ( \"rgb.bmp\" , \"wb\" ), 256 , 256 , p , 0 ); } 上面的代码输出此文件: 函数声明: /*! \\brief Save a RGB/RGBA image in BMP format. \\param TOYBMP_OUTPUT Output stream (by default using file descriptor). \\param w Width of the image. \\param h Height of the image. \\param img Image pixel data in 24-bit RGB or 32-bit RGBA format. \\param alpha Whether the image contains alpha channel. */ void toybmp ( TOYBMP_OUTPUT , unsigned w , unsigned h , const unsigned char * img , int alpha ) 实现 简单介绍下实现要点。不同于PNG与JPG格式，BMP的实现并不复杂。其基本结构如下。 BitmapFileHeader 共14bit 描述bmp格式，显示文件大小 BitmapInfoHeader 共40bit 描述位图的维度，色深，压缩方式 BitmapData 位图像素数据 在位图文件头中值得注意的是，Windows中的数据是倒着显示的。即如果 一段数据显示为36 00 04 00，则实际数据为00 04 00 36。 在位图数据区中，由于位图信息头中的图像高度是正数，所以位图数据在文件中的排列 顺序是从左下角到右上角，以行为主序排列的。可以理解为标准的二维平面坐标系。 此外，24-bit RGB在BMP中按照BGR的顺序储存各通道的值。32-bit RGBA则按照BGRA 顺序储存。 最后是对齐规则。在Windows中，默认扫描的最小单位是4byte，如果数据按此规则对齐 则获取数据的速度会大大加快。也因此，BMP要求每行数据的长度必须是4的倍数，如果 不够则需要在每行末尾补零(比特填充)。 填充后每行的字节数可以表示为: ((宽度*位深+7)/​8+3)/​4 两张调试过程中的错误图片:","tags":"tech","url":"//tooisorahe.com/simple-c-function-bmp.html"},{"title":"秋刀鱼","text":"秋刀鱼，学名Cololabis saira，由于其体形修长如刀，生产季节在秋天，故名秋刀鱼。 因其低廉的价格和相对还行的肉质而常年位于各种烧烤摊、食堂可选用鱼清单的榜首。 以上介绍得自百度百科。 我也是个秋刀鱼的狂热爱好者。曾尝试在学校食堂连续点一周红烧秋刀鱼， 只是因为食堂实在没啥好吃的了 。 当然这已经是过去的事了。 一周前去食堂吃饭，按照惯例要了道秋刀鱼。第一条，还是熟悉的配方，还是熟悉的味道，当然还有熟悉 的吃法————因为秋刀鱼的骨头非常软，我吃的时候一般嚼都不带嚼，直接吞————，天知道那第二条是不是 什么变种货，骨头的硬度基本接近一般的淡水鱼类，我第一口就着了道。尝试了许久也不能将鱼刺咳出， 只好用强行吃饭咽下去。结果咽是咽下去了，但鱼骨也在喉咙上划了道口子。 放假回家时顺路去医院照了个喉镜，结果啥也没查出来，但该膈应还是膈应。 突然想起周杰伦有一首\"七里香\"，里面有一句：秋刀鱼的滋味，猫跟你都想了解。 但我不想了解，暂时一点都不想 所谓一朝被蛇咬，十年怕井绳","tags":"life","url":"//tooisorahe.com/cololabis-saira.html"},{"title":"装了一台学习()用pc","text":"旧电脑已经陪伴我四年有余，日常看看网页，玩下dota2并没有什么问题，但在使用某些软件时就有些捉襟见肘了。 原因也很简单，这台电脑好像是我在初三的暑假在网上捡垃圾收回来的，不过当时也什么都不会，还是基本由班长 (大佬朋友，绰号班长，虽然断了联系许久，但我一直都很感激他)包办。记得cpu是X5570，当年著名的洋垃圾； 虽然是在09年发行的，但在当时是性能中上的一款服务器cpu，4C8T到现在也依然能打。显卡是我过了两年自己上 某宝收的网吧拆机丐中丐962，两百多。 现在好像涨到四百多了，真实理财产品 ，很多游戏都能玩但只能 开低画质。主板是著名寨板大厂华南金牌生产的X58，虽然没有质保但似乎体制比原版还好..现在看来国人的魔改 能力真的太强了。 既然要换电脑，图吧卡吧是免不了要去的，里面的老哥个个是人才说话又好听，还精通如何薅狗东羊毛；真的超喜欢 在里面的。潜伏了几个月之后，得出的配置： 平时对CPU的需求不大，不拖GPU后腿就行，2600X不多说了， AMD，yes！辣鸡牙膏厂滚出！ CPU低了GPU直接拉满，AMD的cpu和gpu的风评完全就是反比，gpu方面感觉amd拍马也赶不上核弹厂，特级厨师不是白叫的。 选了凄惨红的2080tiOC版。七彩虹的售后目前应该是几个大厂里做的最好的，支持个人送保也就不必 担心20系的花花卡了，相比之下打人硕拒保嘉人为泰等等简直是臭名远扬...大头是这两个，其他的都是小意思， 电源1元1w的都没什么问题，瓦数满载再往上加一点就够了。 由于我不是rgb战士，也不搞超频，所以内存都选的2133的普条。不过这次机箱买错了- -，本来以为中塔式是大小适中 的意思，结果买回来机箱净重就有20斤左右..尺寸也比之前的大了一倍。 装好后测了下买了很久的 显卡 天国：救赎，不知道是不是优化太差，全高特效下在野外帧数稳定在140，而在城镇里只能勉强60帧。 可以愉快地开始 学习 ( ? ) 了。","tags":"life","url":"//tooisorahe.com/new-pc.html"},{"title":"博客相关","text":"偶尔想在网路上写些东西，但一直没有想到好的平台。 由于对微信实在是没有好感，所以根本就没有考虑过。 QQ虽然经常用，但对写作并不友好，主要还是朋友之间联系用，所以也剔除。 受到前辈们的启发，我决定搭一个个人博客，这似乎也比较\"符合\"程序员的习惯(?)。 因为对资源没有特殊的需求，所以也没有买额外的服务器，直接用GitHub page搭了 个静态博客，毕竟视频、音频什么的都可以外链解决。 博客引擎是pelican，由python实现。单词的英文翻译是鹈鹕，不过作者似乎是个 法国人..搞不清楚名字的意图。 如果使用GitHub page搭建博客，默认的域名是GitHub用户名+.io。 既然是个人博客，那自然要有定制的元素， 遂去Namecilo上买了 tooisorahe ( 遠 い 空 へ ) .com这个域名。墙外的域名国内解析虽然 慢了点，但可以省去备案之类一系列繁琐操作。 私有的东西还想让我去登记一下简直是无稽之谈 主题来自 farseefc ，我自己再加了些许修改。 评论系统使用了disqus留言，前段时间还是可以正常使用的，不过由于天朝的网络管制条例 \"任何网络上的言论都必须登记在案\"，disqus也光荣地进了小黑屋，目前只有在墙外才能正常 显示。 —之前在网上看到了一段关于\"写博客对程序员重不重要\"的话： 很重要。 你需要一个练习表达能力的地方， 你还需要一个通过表达来梳理思绪的地方， 你更需要有一个树洞。 这大概就是这个博客的目的所在吧。","tags":"life","url":"//tooisorahe.com/my-blog.html"},{"title":"你好 世界","text":"由此启程...","tags":"life","url":"//tooisorahe.com/新的开始.html"}]}